<h2 id="组合数取模">组合数取模</h2>

<p><a href="https://vjudge.net/solution/18275045">使用示例</a></p>

<p>为方便，记$C(n,m)=C_n^m=\binom{n}{m}$。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Factorial</span> <span class="o">:</span> <span class="n">Mod</span>
<span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">ll</span><span class="o">&gt;</span> <span class="n">fac</span><span class="p">,</span> <span class="n">ifac</span><span class="p">;</span>
	<span class="n">Factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">ll</span> <span class="n">M</span><span class="p">)</span> <span class="o">:</span> <span class="n">fac</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ifac</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Mod</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">fac</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">fac</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">),</span> <span class="n">ifac</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">M</span> <span class="o">/</span> <span class="n">i</span><span class="p">,</span> <span class="n">ifac</span><span class="p">[</span><span class="n">M</span> <span class="o">%</span> <span class="n">i</span><span class="p">]);</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">ifac</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">ifac</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ifac</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">ll</span> <span class="n">c</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">fac</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">ifac</span><span class="p">[</span><span class="n">m</span><span class="p">]),</span> <span class="n">ifac</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">]);</span> <span class="p">}</span>
	<span class="n">ll</span> <span class="n">lucas</span><span class="p">(</span><span class="n">ll</span> <span class="n">n</span><span class="p">,</span> <span class="n">ll</span> <span class="n">m</span><span class="p">)</span> <span class="c1">//卢卡斯定理求C(n,m)%M，适用于模数M小于N的情况，或者m较小的时候也可以暴力求</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">||</span> <span class="n">n</span> <span class="o">%</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">%</span> <span class="n">M</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">c</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">lucas</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">M</span><span class="p">,</span> <span class="n">m</span> <span class="o">/</span> <span class="n">M</span><span class="p">),</span> <span class="n">lucas</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">M</span><span class="p">,</span> <span class="n">m</span> <span class="o">%</span> <span class="n">M</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="组合数-lcm">组合数 LCM</h2>

<p>$(n + 1)lcm(C(n,0),C(n,1),\ldots,C(n,k))=lcm(n+1,n,n−1,n−2,\ldots,n−k+1)$</p>

<p>区间 lcm 的维护：对于一个数，将其分解质因数，若有因子$p^k$，那么拆分出 k 个数 $p^1,p^2,\ldots,p^k$，权值都为 p，那么区间$[l,r]$内所有数的 lcm 的答案=所有在该区间中出现过的数的权值之积，可持久化线段树维护之。</p>

<h2 id="stirling-数">Stirling 数</h2>

<h3 id="第一类斯特林数">第一类斯特林数</h3>

<p>第一类斯特林数$S(p,k)$的一个的组合学解释是：将 p 个物体排成 k 个非空循环排列的方法数。</p>

<p>递推公式：$S(p,k)=(p−1)S(p−1,k)+S(p−1,k−1),1\leq k\leq p−1;S(p,0)=0,p\ge1;S(p,p)=1,p\ge0$</p>

<h3 id="第二类斯特林数">第二类斯特林数</h3>

<p>第二类斯特林数$S(p,k)$的一个的组合学解释是：将 p 个物体划分成 k 个非空不可辨别的（可以理解为盒子没有编号）集合的方法数。</p>

<p>递推公式：$S(p,k)=kS(p−1,k)+S(p−1,k−1),1\leq k\leq p−1;S(p,0)=0,p\ge 1;S(p,p)=1,p\ge0$</p>

<p>卷积形式：$S(n,m)=\frac{1}{m!}\sum_{k=0}^m(-1)^kC(m,k)(m-k)^n=\sum_{k=0}^m\frac{(-1)^k}{k!}\frac{(m-k)^n}{(m-k)!}$</p>

<p>同时有转化：$x^k=\sum_{i=1}^ki!C(x,i)S(k,i)$</p>

<h3 id="斯特林近似公式">斯特林近似公式</h3>

<p>$n!\approx\sqrt{2\pi n}(\frac{n}{e})^n$</p>

<h2 id="小球入盒模型通解">小球入盒模型通解</h2>

<table>
  <thead>
    <tr>
      <th>k 个球</th>
      <th>m 个盒子</th>
      <th>空盒子</th>
      <th>方案数</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>各不相同</td>
      <td>各不相同</td>
      <td>允许</td>
      <td>$m^k$</td>
    </tr>
    <tr>
      <td>各不相同</td>
      <td>各不相同</td>
      <td>无</td>
      <td>$m!Stirling2(k,m)$</td>
    </tr>
    <tr>
      <td>各不相同</td>
      <td>完全相同</td>
      <td>允许</td>
      <td>$\sum_{i=1}^mStirling2(k,i)$</td>
    </tr>
    <tr>
      <td>各不相同</td>
      <td>完全相同</td>
      <td>无</td>
      <td>$Stirling2(k,m)$</td>
    </tr>
    <tr>
      <td>完全相同</td>
      <td>各不相同</td>
      <td>允许</td>
      <td>$C(m+k−1,k)$</td>
    </tr>
    <tr>
      <td>完全相同</td>
      <td>各不相同</td>
      <td>无</td>
      <td>$C(k−1,m−1)$</td>
    </tr>
    <tr>
      <td>完全相同</td>
      <td>完全相同</td>
      <td>允许</td>
      <td>$\frac{1}{(1−x)(1−x^2)…(1−x^m)}的x^k项的系数$</td>
    </tr>
    <tr>
      <td>完全相同</td>
      <td>完全相同</td>
      <td>无</td>
      <td>$\frac{x^m}{(1−x)(1−x^2)…(1−x^m)}的x^k项的系数$</td>
    </tr>
  </tbody>
</table>

<h2 id="置换">置换</h2>

<p><a href="https://vjudge.net/solution/18445975">使用示例</a></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Permutation</span> <span class="o">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
	<span class="n">Permutation</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
	<span class="k">friend</span> <span class="n">Permutation</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Permutation</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="n">Permutation</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Permutation</span> <span class="n">ans</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
		<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">friend</span> <span class="n">Permutation</span> <span class="n">inv</span><span class="p">(</span><span class="k">const</span> <span class="n">Permutation</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Permutation</span> <span class="n">ans</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">friend</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">cycle</span><span class="p">(</span><span class="k">const</span> <span class="n">Permutation</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
				<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="n">j</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
					<span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ans</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="生成字典序">生成字典序</h2>

<h3 id="下一排列">下一排列</h3>

<p>对给定的排列$a_1a_2\ldots a_n$，找到$a_j$使得$a_j&lt;a_{j+1},a_{j+1}&gt;a_{j+2}&gt;\ldots&gt;a_n$即这列数中最后一个相邻递增数对，然后把$a_{j+1},a_{j+2},\ldots,a_n$中大于$a_j$的最小数放到位置 j，然后$a_j\ldots a_n$中剩余的数从小到大排序放到$[j+1,n]$中。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">nextPermutation</span><span class="p">(</span><span class="n">ll</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">ll</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="c1">//标准库有这个函数next_permutation</span>
<span class="p">{</span>
	<span class="n">ll</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="o">*</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="o">--</span><span class="n">j</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">j</span><span class="p">)</span>
		<span class="o">--</span><span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">j</span><span class="p">),</span> <span class="n">reverse</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="二项式反演">二项式反演</h2>

<p>$f(n)=\sum_{k=0}^nC(n,k)g(k),g(n)=\sum_{k=0}^n(−1)^{n−k}C(n,k)f(k)$</p>

<h2 id="第-k-小期望">第 k 小期望</h2>

<p>$f(n,k)$表示有 n 个变量，和为 1，第 k 小的期望。</p>

<p>$f(n,k)=\frac{1}{n^2}+(1-\frac{1}{n})f(n-1,k-1),f(n,0)=0$</p>

<h2 id="错排数">错排数</h2>

<p>考虑一个有 n 个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排
列的一个错排。</p>

<p>n 个元素的错排数$D_n$满足递推公式：$D_1=0,D_2=1,D_n=(n−1)(D_{n−2}+D_{n−1})$</p>

<p>通项：$D(n)=n![\frac{(-1)^2}{2!}+\ldots+\frac{(-1)^{n-1} }{(n-1)!}+\frac{(-1)^n}{n!}]=\lfloor\frac{n!}{e}+\frac{1}{2}\rfloor$</p>

<h2 id="bonuli-数">Bonuli 数</h2>

<p><a href="http://www.51nod.com/Challenge/ProblemSubmitDetail.html#!#judgeId=744601">使用示例</a></p>

<p>$B_n = -\frac{1}{C(n+1,n)}(C(n+1,0)B_0+C(n+1,1)B_1+\ldots+C(n+1,n-1)B_{n-1})=-\frac{1}{n+1}(C(n+1,0)B_0+C(n+1,1)B_1+\ldots+C(n+1,n-1)B_{n-1})$</p>

<p>可用于计算任意<strong>正整数</strong>次数的幂和：$\sum_{i=1}^ni^k=\frac{1}{k+1}\sum_{j=0}^kC(k+1,j)B_jn^{k+1-j}$</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Bonuli</span> <span class="o">:</span> <span class="n">Factorial</span>
<span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">ll</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">Bonuli</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">ll</span> <span class="n">M</span><span class="p">)</span> <span class="o">:</span> <span class="n">Factorial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
				<span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">qadd</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mul</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">c</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)));</span>
			<span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">qadd</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="o">-</span><span class="n">mul</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mul</span><span class="p">(</span><span class="n">fac</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ifac</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ll</span> <span class="n">ask</span><span class="p">(</span><span class="n">ll</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ll</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">qadd</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">)));</span>
		<span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">fac</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">ifac</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]));</span>
	<span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div>

<h2 id="catalan-数">Catalan 数</h2>

<p>$h_1=1,h_n=\frac{4n−2}{n+1}h_{n−1}=\frac{C(2n,n)}{n+1}=C(2n,n)−C(2n,n−1)$。</p>

<p>在一个格点阵列中，从$(0,0)$点走到$(n,m)$点且不经过对角线$x=y$的方法数：$C(n+m−1,m)−C(n+m−1,m−1),x&gt;y;C(n+m,m)−C(n+m,m−1),x\ge y$。</p>

<p>常见的 Catalan 数：括号序的个数、凸多边形三角剖分的方案数等。</p>

<h2 id="bell-数">Bell 数</h2>

<p>把 n 个带标号的物品划分为若干不相交集合的方案数称为贝尔数，其递推公式：$B_n=\sum_{i=0}^{N-1}C_{n-1}^iB_i$</p>

<p>前几项贝尔数：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1,2,5,15,52,203,877,4140,21147,115975,678570,4213597,27644437,190899322,1382958545,...
</code></pre></div></div>

<h3 id="等价类容斥">等价类容斥</h3>

<p>考虑容斥，Bell(p)枚举所有等价情况。对于一种情况，强制了一个等价类里面的数都要相同，其它的可以相同也可以不同。</p>

<p>容斥系数为：$(−1)^{p−等价类个数}(每个等价类大小−1)!之积$。</p>

<h2 id="grey-码">Grey 码</h2>

<p>格雷序列第 i 个是<code class="highlighter-rouge">i^(i&gt;&gt;1)</code>。长为 n 的 01 序列共$2^n$个，下标从$0\ldots 2^n-1$。</p>

<h2 id="扩展-cayley-公式">扩展 Cayley 公式</h2>

<p>对于 n 个点，m 个连通块的图，假设每个连通块有 a[i]个点，那么用 s−1 条边把它连通的方案数为$n^{s−2}a[1]a[2]\ldots a[m]$。</p>

<h2 id="超立方体">超立方体</h2>

<p>n 维超立方体有$2^{n−i}C(n,i)$个 i 维元素。</p>

<h2 id="枚举位集-i-的非空子集-j">枚举位集 I 的非空子集 J</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="n">J</span><span class="o">=</span><span class="n">I</span><span class="p">;</span> <span class="n">J</span><span class="p">;</span> <span class="n">J</span><span class="o">=</span><span class="n">I</span><span class="o">&amp;</span><span class="n">J</span><span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>
